# Протокол чтения данных сенсоров теплового насоса

## Общая информация

- **Тип соединения**: TCP Socket
- **IP адрес по умолчанию**: 192.168.4.1
- **Порт**: 333 (согласно официальной документации ТЭМЗИТ)
- **Размер ответа**: 64 байта
- **Формат**: Бинарный протокол с CRC проверкой

**Примечание:** Протокол соответствует [официальной документации ТЭМЗИТ](https://temzit.ru/downloads/HM_Protocol.pdf). Команда SYNC (0x30) в документации соответствует GET_STATE в Android приложении.

## Запрос данных

### GET_STATE (0x30 / 48)

**Структура запроса:**
```
Байт 0: 0x30 (тип пакета GET_STATE)
Байт 1: 0x00
Размер: 2 байта
```

**Пример кода:**
```python
request = bytes([0x30, 0x00])
sock.sendall(request)
```

## Структура ответа

Ответ всегда имеет размер 64 байта и содержит данные сенсоров и состояние устройства.

### Общая структура

```
Байт 0:   Тип ответа (0x00 = DATA0 или 0x01 = DATA1)
Байт 1:   Резерв
Байты 2-61: Данные сенсоров и настроек
Байты 62-63: CRC (контрольная сумма, word, little-endian)
```

### Детальная карта данных

| Смещение | Размер | Название | Тип | Описание |
|----------|--------|----------|-----|----------|
| 0 | 1 | Type | byte | Тип ответа (0x00 или 0x01) |
| 1 | 1 | Reserved | byte | Резерв |
| 2-3 | 2 | State | word | Состояние устройства (0=стоп, 1-4=нагрев, 5=холод, 100-103=ГВС) |
| 4-5 | 2 | Schedule | word | Расписание |
| 6-7 | 2 | Tout | int16 | Температура наружного воздуха (°C, значение / 10.0) |
| 8-9 | 2 | Tin | int16 | Температура входящего воздуха (°C, значение / 10.0) |
| 10-11 | 2 | Tf | int16 | Температура подачи (°C, значение / 10.0) |
| 12-13 | 2 | Tb | int16 | Температура обратки (°C, значение / 10.0) |
| 14-15 | 2 | Tcond | int16 | Температура конденсатора (°C, значение / 10.0) |
| 16-17 | 2 | Tevap | int16 | Температура испарителя (°C, значение / 10.0) |
| 18-19 | 2 | Tgvs | int16 | Температура ГВС (°C, значение / 10) |
| 20-21 | 2 | Flow | word | Расход (младший байт = Flow, старший = Flow2, л/мин) |
| 22-23 | 2 | Reserved | word | Резерв |
| 24-25 | 2 | CompFreq | word | Частота компрессора (младший байт = CompFreq, старший = CompFreq2, Гц) |
| 26-29 | 4 | Reserved | - | Резерв |
| 30-31 | 2 | Pin | int16 | Мощность потребления (кВт, значение / 10.0) |
| 32-33 | 2 | Failures | word | Код ошибок |
| 34-35 | 2 | Tf2 | int16 | Температура подачи 2 (°C, значение / 10.0) |
| 36-37 | 2 | Tb2 | int16 | Температура обратки 2 (°C, значение / 10.0) |
| 38-39 | 2 | Tcond2 | int16 | Температура конденсатора 2 (°C, значение / 10.0) |
| 40-41 | 2 | Tevap2 | int16 | Температура испарителя 2 (°C, значение / 10.0) |
| 42-43 | 2 | Reserved | word | Резерв |
| 44 | 1 | Flags | byte | Флаги (бит 0: Dualmode, 0=включен, 1=выключен) |
| 45-46 | 2 | ControllerRevision | - | Ревизия контроллера (byte[45] * 100 + byte[46]) |
| 47 | 1 | ReceivedPage | byte | Текущая страница |
| 48 | 1 | ModeSet | byte | Режим установлен |
| 49 | 1 | Begin | byte | Начало расписания (часы, 0-23) |
| 50 | 1 | End | byte | Конец расписания (часы, 0-23) |
| 51 | 1 | TroomSet | byte | Температура помещения установлена |
| 52 | 1 | TwaterSet | byte | Температура воды установлена |
| 53 | 1 | TgvsSet | byte | Температура ГВС установлена |
| 54-55 | 2 | Reserved | word | Резерв |
| 56 | 1 | GVSModeSet | byte | Режим ГВС установлен |
| 57-58 | 2 | Reserved | word | Резерв |
| 59 | 1 | Hour | BCD | Часы (старший полубайт = десятки, младший = единицы) |
| 60 | 1 | Minute | BCD | Минуты (старший полубайт = десятки, младший = единицы) |
| 61 | 1 | Second | BCD | Секунды (старший полубайт = десятки, младший = единицы) |
| 62-63 | 2 | CRC | word | Контрольная сумма (little-endian) |

## Форматы данных

### Word (16-битное значение, little-endian)

Младший байт идет первым:

```python
def get_word(data, offset):
    return (data[offset] & 0xFF) | ((data[offset + 1] & 0xFF) << 8)
```

**Пример:**
- Байты: `[0x34, 0x12]`
- Значение: `0x1234` (4660 в десятичной)

### Int16 со знаком (для температур)

16-битное знаковое число. Если значение >= 32768, то это отрицательное число:

```python
def int16_to_float(value):
    if value >= 32768:
        value -= 65536
    return value / 10.0
```

**Примеры:**
- `0x000A` (10) → `1.0°C`
- `0xFFF6` (65526) → `65526 - 65536 = -10` → `-1.0°C`

### BCD время (двоично-десятичный код)

Каждый байт содержит две цифры в BCD формате:

```python
def parse_bcd_time(data, hour_offset, min_offset, sec_offset):
    hour_lo = data[hour_offset] & 0x0F
    hour_hi = (data[hour_offset] >> 4) & 0x0F
    hour = hour_hi * 10 + hour_lo
    
    min_lo = data[min_offset] & 0x0F
    min_hi = (data[min_offset] >> 4) & 0x0F
    minute = min_hi * 10 + min_lo
    
    sec_lo = data[sec_offset] & 0x0F
    sec_hi = (data[sec_offset] >> 4) & 0x0F
    second = sec_hi * 10 + sec_lo
    
    return f"{hour:02d}:{minute:02d}:{second:02d}"
```

**Пример:**
- Байт 59: `0x14` → `0x1` (десятки) и `0x4` (единицы) → `14 часов`
- Байт 60: `0x30` → `0x3` (десятки) и `0x0` (единицы) → `30 минут`

### Составные значения

#### Расход (Flow)

Байты 20-21 содержат два значения в одном word:
- Младший байт (байт 20): Flow (л/мин)
- Старший байт (байт 21): Flow2 (л/мин)

```python
flow_word = get_word(data, 20)
Flow = flow_word & 0xFF
Flow2 = (flow_word >> 8) & 0xFF
```

#### Частота компрессора (CompFreq)

Аналогично расходу:
- Младший байт: CompFreq (Гц)
- Старший байт: CompFreq2 (Гц)

```python
comp_word = get_word(data, 24)
CompFreq = comp_word & 0xFF
CompFreq2 = (comp_word >> 8) & 0xFF
```

## Состояния устройства

Значения поля `State` (байты 2-3):

| Значение | Описание |
|----------|----------|
| 0 | Стоп |
| 1-4 | Нагрев |
| 5 | Холод |
| 100-103 | ГВС (103 = ГВС*) |

## Вычисление выходной мощности

Выходная мощность вычисляется на основе расхода и разности температур:

```python
# Для первого контура
Pout = ((Flow * 1.25 * 60.0 * (Tf - Tb)) / 100.0) / 10.0

# Для второго контура (если Dualmode = 1)
Pout2 = ((Flow2 * 1.25 * 60.0 * (Tf2 - Tb2)) / 100.0) / 10.0
```

Где:
- `Flow` - расход в л/мин
- `1.25` - коэффициент (плотность воды * теплоемкость)
- `60.0` - секунды в минуте
- `(Tf - Tb)` - разность температур в градусах
- Результат в кВт

## Проверка CRC

CRC проверяется для всех входящих пакетов:

```python
def check_crc(data):
    """Проверка CRC ответа"""
    crc_sum = sum(data[i] & 0xFF for i in range(62)) & 0xFFFF
    received_crc = get_word(data, 62)
    return crc_sum == received_crc
```

CRC вычисляется как сумма всех байтов от 0 до 61 включительно (младшие 16 бит).

## Пример полного цикла чтения

```python
import socket

# 1. Создание соединения
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.settimeout(5.0)
sock.connect(("192.168.4.1", 80))

# 2. Отправка запроса
request = bytes([0x30, 0x00])
sock.sendall(request)

# 3. Получение ответа
response = bytearray(64)
bytes_read = 0
while bytes_read < 64:
    n = sock.recv_into(response, 64 - bytes_read)
    if n == 0:
        break
    bytes_read += n

# 4. Проверка типа ответа
if response[0] not in [0x00, 0x01]:
    print(f"Неверный тип ответа: {response[0]}")
    sock.close()
    exit(1)

# 5. Проверка CRC
if not check_crc(response):
    print("Ошибка CRC!")
    sock.close()
    exit(1)

# 6. Парсинг данных
data = parse_sensor_data(response)

# 7. Использование данных
print(f"Время: {data['time']}")
print(f"Состояние: {data['state']}")
print(f"Tout: {data['Tout']:.1f}°C")
print(f"Tf: {data['Tf']:.1f}°C")
print(f"Tb: {data['Tb']:.1f}°C")
print(f"Мощность: {data['Pin']:.1f} кВт")

sock.close()
```

## Особенности

1. **Dualmode**: Для устройств с ревизией > 264 поддерживается двухконтурный режим. При Dualmode = 1 доступны данные второго контура (Tf2, Tb2, Tcond2, Tevap2, Flow2, CompFreq2, Pout2).

2. **Ревизия контроллера**: Определяется как `byte[45] * 100 + byte[46]`. Например, `0x01 0x0A` = 1 * 100 + 10 = 110.

3. **Время устройства**: Передается в BCD формате. Учитывайте, что это время самого устройства, а не время запроса.

4. **Температуры**: Большинство температур передаются как int16 со знаком и делятся на 10. Исключение: Tgvs делится на 10 без преобразования знака.

5. **Ошибки**: Поле Failures содержит битовую маску ошибок. Нулевое значение означает отсутствие ошибок.

6. **Расписание**: Поле Schedule указывает на активное расписание. Значения Begin и End указывают часы начала и конца расписания.

## Примечания

- Все word значения передаются в формате little-endian
- Температуры могут быть отрицательными (используется int16 со знаком)
- Время передается в BCD формате
- CRC проверка обязательна для всех ответов
- Размер ответа всегда 64 байта
- Устройство может отправлять данные автоматически без запроса (периодически)


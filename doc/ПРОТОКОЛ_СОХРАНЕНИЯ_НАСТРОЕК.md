# Протокол сохранения настроек в тепловой насос

## Общая информация

- **Тип соединения**: TCP Socket
- **IP адрес по умолчанию**: 192.168.4.1
- **Порт**: 333 (согласно официальной документации ТЭМЗИТ)
- **Размер пакета**: 64 байта (для приема данных)
- **Кодировка**: Бинарный протокол

**Примечание:** Данный протокол основан на анализе Android приложения и в целом соответствует [официальной документации ТЭМЗИТ](https://temzit.ru/downloads/HM_Protocol.pdf), но имеет некоторые отличия. См. файл `СРАВНЕНИЕ_С_ОФИЦИАЛЬНЫМ_ПРОТОКОЛОМ.md` для детального сравнения.

## Типы пакетов для сохранения настроек

### 1. SEND_SETTINGS (0x35 / 53) - Отправка всех настроек

**Структура пакета:**
```
Байт 0:  0x35 (тип пакета SEND_SETTINGS)
Байт 1:  0x1A (26 - длина данных)
Байты 2-27: Данные настроек (26 байт в HEX формате)
Байт 28-30: Резерв (0x00)
Байт 31: CRC (контрольная сумма)
```

**Размер пакета:** 32 байта

**Пример кода:**
```java
byte[] packet = new byte[32];
packet[0] = 0x35;  // SEND_SETTINGS
packet[1] = 26;    // Длина данных
// Конвертация HEX строки в байты
for (int i = 0; i < 26; i++) {
    int offset = i * 2;
    packet[i + 2] = (byte) ((hexToBin(config.charAt(offset)) << 4) | 
                            hexToBin(config.charAt(offset + 1)));
}
packet[31] = 0;
CalcCRC(packet, 31);  // Вычисление CRC
```

**Формат данных настроек (config):**
- HEX строка длиной 52 символа (26 байт)
- Каждый параметр занимает 1 байт
- Пример: `"01101E00F6E7052300000A0500010613590F030000000F0000055A00"`

### 2. CHANGE_ONE_SETTING (0x32 / 50) - Изменение одного параметра

**Структура пакета:**
```
Байт 0:  0x32 (тип пакета CHANGE_ONE_SETTING)
Байт 1:  0x00
Байт 2:  0x00
Байт 3:  Номер параметра (0-255)
Байт 4:  0x00
Байт 5:  Значение параметра (0-255)
Байт 6:  0x00
Байт 7:  CRC (контрольная сумма)
```

**Размер пакета:** 8 байт

**Пример кода:**
```java
byte[] packet = new byte[8];
packet[0] = 0x32;  // CHANGE_ONE_SETTING
packet[1] = 0x00;
packet[2] = 0x00;
packet[3] = (byte) (paramNum & 0xFF);  // Номер параметра
packet[4] = 0x00;
packet[5] = (byte) (paramValue & 0xFF);  // Значение
packet[6] = 0x00;
packet[7] = 0x00;
CalcCRC(packet, 7);  // Вычисление CRC
```

### 3. SEND_RTCSETTINGS (0x37 / 55) - Отправка настроек расписания

**Структура пакета:**
```
Байт 0:  0x37 (тип пакета SEND_RTCSETTINGS)
Байт 1:  0x28 (40 - длина данных)
Байты 2-41: Данные расписания (40 байт в HEX формате)
Байт 42: CRC (контрольная сумма)
```

**Размер пакета:** 42 байта

**Формат данных расписания (RTCconfig):**
- HEX строка длиной 80 символов (40 байт)
- Пример: `"00000010101400000000000000101014000000000000001010140000000000000010101400000000"`

### 4. CHANGE_ONE_RTCSETTING (0x33 / 51) - Изменение одного параметра расписания

**Структура пакета:**
```
Байт 0:  0x33 (тип пакета CHANGE_ONE_RTCSETTING)
Байт 1:  0x00
Байт 2:  0x00
Байт 3:  Номер параметра (0-255)
Байт 4:  0x00
Байт 5:  Значение параметра (0-255)
Байт 6:  0x00
Байт 7:  CRC (контрольная сумма)
```

**Размер пакета:** 8 байт

## Вычисление CRC (контрольной суммы)

CRC вычисляется как сумма всех байтов пакета до байта CRC (включительно, но CRC байт изначально равен 0):

```java
public static void CalcCRC(byte[] data, int crcIndex) {
    int sum = 0;
    for (int i = 0; i < crcIndex; i++) {
        sum += data[i] & 0xFF;
    }
    data[crcIndex] = (byte) (sum & 0xFF);
}
```

**Важно:** CRC - это младший байт суммы всех предыдущих байтов.

## Структура данных настроек (config)

Настройки хранятся в виде HEX строки. Каждый байт соответствует определенному параметру:

- **Байт 0**: Режим работы (0-255)
- **Байт 1**: Температура в помещении (16-255, фактическое значение = байт - 16)
- **Байт 2**: Температура воды (обратки) 
  - Для версии >= 332: фактическое значение = байт - 5
  - Для версии < 332: фактическое значение = байт - 16
- **Байт 3**: 
  - Младшие 2 бита: Режим вспомогательного ТЭНа (0-3)
  - Старшие 4 бита: Коэффициент инерции дома (0-15)
- **Байт 4**: Температура включения ТЭНа (фактическое значение = байт + 25)
- **Байт 5**: Температура выключения компрессора (фактическое значение = байт + 25)
- **Байт 6**: 
  - Младшие 4 бита: Режим работы ГВС (0-15)
- **Байт 7**: Температура ГВС (фактическое значение = байт - 20)
- **Байт 8**: Внешний нагреватель (младшие 4 бита, 0-15)
- **Байт 9**: Ограничение мощности компрессора (0-255)
- **Байт 18**: Погодокомпенсация (0-255)
- **Байт 21**: Максимальная температура нагрева от ТН (0-255)
- **Байты 30-31**: Версия контроллера (4 байта в HEX, старшие разряды)
- **Байты 60-63**: Ревизия контроллера (4 байта в HEX)

## Процесс отправки настроек

1. **Установка TCP соединения** с устройством (IP: 192.168.4.1)
2. **Ожидание готовности** устройства (проверка доступности данных)
3. **Отправка пакета** через `socket.getOutputStream().write()`
4. **Ожидание ответа** (64 байта)
5. **Проверка CRC** полученного ответа

## Пример полного цикла сохранения настроек

```java
// 1. Создание сокета
Socket socket = new Socket("192.168.4.1", PORT);

// 2. Подготовка пакета
byte[] packet = new byte[32];
packet[0] = 0x35;  // SEND_SETTINGS
packet[1] = 26;    // Длина данных

// 3. Конвертация HEX строки в байты
String config = "01101E00F6E7052300000A0500010613590F030000000F0000055A00";
for (int i = 0; i < 26; i++) {
    int offset = i * 2;
    char c1 = config.charAt(offset);
    char c2 = config.charAt(offset + 1);
    packet[i + 2] = (byte) ((hexToBin(c1) << 4) | hexToBin(c2));
}

// 4. Вычисление CRC
packet[31] = 0;
CalcCRC(packet, 31);

// 5. Отправка пакета
socket.getOutputStream().write(packet, 0, 32);

// 6. Ожидание ответа
byte[] response = new byte[64];
socket.getInputStream().read(response);

// 7. Проверка CRC ответа
int sum = 0;
for (int i = 0; i < 62; i++) {
    sum += response[i] & 0xFF;
}
int receivedCRC = (response[62] & 0xFF) | ((response[63] & 0xFF) << 8);
if (sum != receivedCRC) {
    // Ошибка CRC
}
```

## Дополнительные типы пакетов

### GET_SETTINGS (0x34 / 52) - Получение настроек
```
Байт 0: 0x34
Размер: 1 байт
```

### GET_RTCSETTINGS (0x36 / 54) - Получение настроек расписания
```
Байт 0: 0x36
Размер: 1 байт
```

### GET_STATE (0x30 / 48) - Получение состояния
```
Байт 0: 0x30
Байт 1: 0x00
Размер: 2 байта
```

## Протокол чтения данных сенсоров

### GET_STATE (0x30 / 48) - Запрос данных сенсоров

**Структура запроса:**
```
Байт 0: 0x30 (тип пакета GET_STATE)
Байт 1: 0x00
Размер: 2 байта
```

**Структура ответа (64 байта):**
```
Байт 0:   Тип ответа (0x00 = DATA0 или 0x01 = DATA1)
Байт 1:   Резерв
Байты 2-3:   Состояние (word, little-endian)
Байты 4-5:   Расписание (word, little-endian)
Байты 6-7:   Температура наружного воздуха Tout (int16, значение / 10.0)
Байты 8-9:   Температура входящего воздуха Tin (int16, значение / 10.0)
Байты 10-11: Температура подачи Tf (int16, значение / 10.0)
Байты 12-13: Температура обратки Tb (int16, значение / 10.0)
Байты 14-15: Температура конденсатора Tcond (int16, значение / 10.0)
Байты 16-17: Температура испарителя Tevap (int16, значение / 10.0)
Байты 18-19: Температура ГВС Tgvs (int16, значение / 10)
Байты 20-21: Расход Flow (word: младший байт = Flow, старший = Flow2)
Байты 22-23: Резерв
Байты 24-25: Частота компрессора CompFreq (word: младший байт = CompFreq, старший = CompFreq2)
Байты 26-27: Резерв
Байты 28-29: Резерв
Байты 30-31: Мощность потребления Pin (int16, значение / 10.0)
Байты 32-33: Ошибки Failures (word)
Байты 34-35: Температура подачи 2 Tf2 (int16, значение / 10.0)
Байты 36-37: Температура обратки 2 Tb2 (int16, значение / 10.0)
Байты 38-39: Температура конденсатора 2 Tcond2 (int16, значение / 10.0)
Байты 40-41: Температура испарителя 2 Tevap2 (int16, значение / 10.0)
Байт 44:   Флаги (бит 0: Dualmode)
Байты 45-46: Ревизия контроллера (ControllerRevision = byte[45] * 100 + byte[46])
Байт 47:   Текущая страница (ReceivedPage)
Байт 48:   Режим установлен (ModeSet)
Байт 49:   Начало расписания (Begin, часы)
Байт 50:   Конец расписания (End, часы)
Байт 51:   Температура помещения установлена (TroomSet)
Байт 52:   Температура воды установлена (TwaterSet)
Байт 53:   Температура ГВС установлена (TgvsSet)
Байт 54-55: Резерв
Байт 56:   Режим ГВС установлен (GVSModeSet)
Байты 59-61: Время устройства (BCD формат)
  - Байт 59: Часы (старший полубайт = hour_hi, младший = hour_lo)
  - Байт 60: Минуты (старший полубайт = min_hi, младший = min_lo)
  - Байт 61: Секунды (старший полубайт = sec_hi, младший = sec_lo)
Байты 62-63: CRC (word, little-endian)
```

### Формат данных

**Word (16-битное значение, little-endian):**
```java
int getWord(byte[] data, int offset) {
    return (data[offset] & 0xFF) | ((data[offset + 1] & 0xFF) << 8);
}
```

**Int16 со знаком (для температур):**
```java
float int16ToFloat(int value) {
    if (value >= 32768) {
        value -= 65536;  // Преобразование в отрицательное
    }
    return value / 10.0f;
}
```

**BCD время:**
```java
int hour_lo = data[59] & 0x0F;
int hour_hi = (data[59] >> 4) & 0x0F;
int hour = hour_hi * 10 + hour_lo;
```

### Пример парсинга данных

```java
public void ParseParam(byte[] data) {
    // Время
    int hour_lo = data[61] & 0x0F;
    int hour_hi = (data[61] >> 4) & 0x0F;
    int min_lo = data[60] & 0x0F;
    int min_hi = (data[60] >> 4) & 0x0F;
    int sec_lo = data[61] & 0x0F;
    int sec_hi = (data[61] >> 4) & 0x0F;
    
    // Основные данные
    int state = getWord(data, 2);
    int schedule = getWord(data, 4);
    float Tout = int16ToFloat(getWord(data, 6));
    float Tin = getWord(data, 8) / 10.0f;
    float Tf = getWord(data, 10) / 10.0f;
    float Tb = getWord(data, 12) / 10.0f;
    int Tcond = (int)int16ToFloat(getWord(data, 14));
    int Tevap = (int)int16ToFloat(getWord(data, 16));
    int Tgvs = getWord(data, 18) / 10;
    
    // Расход
    int Flow = getWord(data, 20) & 0xFF;
    int Flow2 = (getWord(data, 20) >> 8) & 0xFF;
    
    // Частота компрессора
    int CompFreq = getWord(data, 24) & 0xFF;
    int CompFreq2 = (getWord(data, 24) >> 8) & 0xFF;
    
    // Мощность
    float Pin = getWord(data, 30) / 10.0f;
    
    // Ошибки
    long Failures = getWord(data, 32) & 0xFFFF;
    
    // Второй контур (если Dualmode = 1)
    float Tf2 = getWord(data, 34) / 10.0f;
    float Tb2 = getWord(data, 36) / 10.0f;
    int Tcond2 = (int)int16ToFloat(getWord(data, 38));
    int Tevap2 = (int)int16ToFloat(getWord(data, 40));
    
    // Флаги и настройки
    int Dualmode = (data[44] & 1) == 0 ? 1 : 0;
    int ControllerRevision = (data[45] & 0xFF) * 100 + (data[46] & 0xFF);
    int ReceivedPage = data[47] & 0xFF;
    int ModeSet = data[48] & 0xFF;
    int Begin = data[49] & 0xFF;
    int End = data[50] & 0xFF;
    int TroomSet = data[51] & 0xFF;
    int TwaterSet = data[52] & 0xFF;
    int TgvsSet = data[53] & 0xFF;
    int GVSModeSet = data[56] & 0xFF;
    
    // Вычисление выходной мощности
    float Pout = ((Flow * 1.25f * 60.0f * (Tf - Tb)) / 100.0f) / 10.0f;
    float Pout2 = ((Flow2 * 1.25f * 60.0f * (Tf2 - Tb2)) / 100.0f) / 10.0f;
}
```

### Проверка CRC ответа

```java
public boolean checkCRC(byte[] data) {
    int sum = 0;
    for (int i = 0; i < 62; i++) {
        sum += data[i] & 0xFF;
    }
    int receivedCRC = getWord(data, 62);
    return (sum & 0xFFFF) == receivedCRC;
}
```

### Пример полного цикла чтения данных

```java
// 1. Создание сокета
Socket socket = new Socket("192.168.4.1", PORT);

// 2. Отправка запроса
byte[] request = new byte[]{0x30, 0x00};
socket.getOutputStream().write(request);

// 3. Ожидание данных (64 байта)
byte[] response = new byte[64];
int bytesRead = 0;
while (bytesRead < 64) {
    int n = socket.getInputStream().read(response, bytesRead, 64 - bytesRead);
    if (n < 0) break;
    bytesRead += n;
}

// 4. Проверка типа ответа
if (response[0] == 0x00 || response[0] == 0x01) {
    // Это данные сенсоров
    
    // 5. Проверка CRC
    if (!checkCRC(response)) {
        System.out.println("Ошибка CRC!");
        return;
    }
    
    // 6. Парсинг данных
    ParseParam(response);
    
    // 7. Использование данных
    System.out.println("Состояние: " + state);
    System.out.println("Tout: " + Tout + "°C");
    System.out.println("Tin: " + Tin + "°C");
    System.out.println("Tf: " + Tf + "°C");
    System.out.println("Tb: " + Tb + "°C");
    System.out.println("Мощность: " + Pin + " кВт");
}

socket.close();
```

### Состояния устройства (state)

Значения состояния из кода:
- `0`: стоп
- `1-4`: нагрев
- `5`: холод
- `100-103`: ГВС (ГВС* для 103)

## Примечания

1. Все числовые значения передаются в байтах (0-255)
2. Температуры хранятся с офсетами (см. структуру данных)
3. Некоторые параметры используют битовые маски (например, байт 3)
4. CRC проверяется для всех входящих пакетов
5. Размер ответа всегда 64 байта
6. Пакеты отправляются синхронно (ожидается ответ перед следующей отправкой)
7. Word значения передаются в формате little-endian (младший байт первый)
8. Температуры в формате int16 со знаком, делятся на 10 для получения градусов
9. Время передается в BCD формате (двоично-десятичный код)
10. Для устройств с ревизией > 264 поддерживается Dualmode (два контура)

